Info file ./gdb.info, produced by Makeinfo, -*- Text -*- from input
file gdb-all.texi.

START-INFO-DIR-ENTRY
* Gdb: (gdb).                   The GNU debugger.
END-INFO-DIR-ENTRY
   This file documents the GNU debugger GDB.

   This is Edition 4.01, January 1992, of `Using GDB: A Guide to the
GNU Source-Level Debugger' for GDB Version 4.4.

   Copyright (C) 1988, 1989, 1990, 1991 1992 Free Software Foundation,
Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the Free
Software Foundation instead of in the original English.


File: gdb.info,  Node: Files,  Next: Symbol Errors,  Prev: GDB Files,  Up: GDB Files

Commands to Specify Files
=========================

   The usual way to specify executable and core dump file names is with
the command arguments given when you start GDB, (*note Getting In and
Out of GDB: Invocation..

   Occasionally it is necessary to change to a different file during a
GDB session.  Or you may run GDB and forget to specify the files you
want to use.  In these situations the GDB commands to specify new files
are useful.

`file FILENAME'
     Use FILENAME as the program to be debugged.  It is read for its
     symbols and for the contents of pure memory.  It is also the
     program executed when you use the `run' command.  If you do not
     specify a directory and the file is not found in GDB's working
     directory, GDB uses the environment variable `PATH' as a list of
     directories to search, just as the shell does when looking for a
     program to run.  You can change the value of this variable, for
     both GDB and your program, using the `path' command.

`file'
     `file' with no argument makes GDB discard any information it has
     on both executable file and the symbol table.

`exec-file [ FILENAME ]'
     Specify that the program to be run (but not the symbol table) is
     found in FILENAME.  GDB will search the environment variable
     `PATH' if necessary to locate your program.  Omitting FILENAME
     means to discard information on the executable file.

`symbol-file [ FILENAME ]'
     Read symbol table information from file FILENAME.  `PATH' is
     searched when necessary.  Use the `file' command to get both
     symbol table and program to run from the same file.

     `symbol-file' with no argument clears out GDB's information on
     your program's symbol table.

     The `symbol-file' command causes GDB to forget the contents of its
     convenience variables, the value history, and all breakpoints and
     auto-display expressions.  This is because they may contain
     pointers to the internal data recording symbols and data types,
     which are part of the old symbol table data being discarded
     inside GDB.

     `symbol-file' will not repeat if you press RET again after
     executing it once.

     On some kinds of object files, the `symbol-file' command does not
     actually read the symbol table in full right away.  Instead, it
     scans the symbol table quickly to find which source files and
     which symbols are present.  The details are read later, one
     source file at a time, as they are needed.

     The purpose of this two-stage reading strategy is to make GDB
     start up faster.  For the most part, it is invisible except for
     occasional pauses while the symbol table details for a particular
     source file are being read.  (The `set verbose' command can turn
     these pauses into messages if desired. *Note Optional Warnings
     and Messages: Messages/Warnings.)

     When the symbol table is stored in COFF format, `symbol-file' does
     read the symbol table data in full right away.  We have not
     implemented the two-stage strategy for COFF yet.

     When GDB is configured for a particular environment, it will
     understand debugging information in whatever format is the
     standard generated for that environment; you may use either a GNU
     compiler, or other compilers that adhere to the local
     conventions.  Best results are usually obtained from GNU
     compilers; for example, using `gcc' you can generate debugging
     information for optimized code.

`core-file [ FILENAME ]'
     Specify the whereabouts of a core dump file to be used as the
     "contents of memory".  Traditionally, core files contain only
     some parts of the address space of the process that generated
     them; GDB can access the executable file itself for other parts.

     `core-file' with no argument specifies that no core file is to be
     used.

     Note that the core file is ignored when your program is actually
     running under GDB.  So, if you have been running your program and
     you wish to debug a core file instead, you must kill the
     subprocess in which the program is running.  To do this, use the
     `kill' command (*note Killing the Child Process: Kill Process.).

`load FILENAME'
     Depending on what remote debugging facilities are configured into
     GDB, the `load' command may be available.  Where it exists, it is
     meant to make FILENAME (an executable) available for debugging on
     the remote system--by downloading, or dynamic linking, for
     example.  `load' also records FILENAME's symbol table in GDB, like
     the `add-symbol-file' command.

     If `load' is not available on your GDB, attempting to execute it
     gets the error message "`You can't do that when your target is
     ...'"

     On VxWorks, `load' will dynamically link FILENAME on the current
     target system as well as adding its symbols in GDB.

     With the Nindy interface to an Intel 960 board, `load' will
     download FILENAME to the 960 as well as adding its symbols in GDB.

     `load' will not repeat if you press RET again after using it.

`add-symbol-file FILENAME ADDRESS'
     The `add-symbol-file' command reads additional symbol table
     information from the file FILENAME.  You would use this command
     when FILENAME has been dynamically loaded (by some other means)
     into the program that is running.  ADDRESS should be the memory
     address at which the file has been loaded; GDB cannot figure this
     out for itself.

     The symbol table of the file FILENAME is added to the symbol table
     originally read with the `symbol-file' command.  You can use the
     `add-symbol-file' command any number of times; the new symbol
     data thus read keeps adding to the old.  To discard all old
     symbol data instead, use the `symbol-file' command.

     `add-symbol-file' will not repeat if you press RET after using it.

`info files'
`info target'
     `info files' and `info target' are synonymous; both print the
     current targets (*note Specifying a Debugging Target: Targets.),
     including the names of the executable and core dump files
     currently in use by GDB, and the files from which symbols were
     loaded.  The command `help targets' lists all possible targets
     rather than current ones.

   All file-specifying commands allow both absolute and relative file
names as arguments.  GDB always converts the file name to an absolute
path name and remembers it that way.

   GDB supports the SunOS shared library format.  GDB automatically
loads symbol definitions from shared libraries when you use the `run'
command, or when you examine a core file.  (Before you issue the `run'
command, GDB will not understand references to a function in a shared
library, however--unless you are debugging a core file).

`info share'
`info sharedlibrary'
     Print the names of the shared libraries which are currently
     loaded.

`sharedlibrary REGEX'
`share REGEX'
     This is an obsolescent command; you can use it to explicitly load
     shared object library symbols for files matching a UNIX regular
     expression, but as with files loaded automatically, it will only
     load shared libraries required by your program for a core file or
     after typing `run'.  If REGEX is omitted all shared libraries
     required by your program are loaded.


File: gdb.info,  Node: Symbol Errors,  Prev: Files,  Up: GDB Files

Errors Reading Symbol Files
===========================

   While reading a symbol file, GDB will occasionally encounter
problems, such as symbol types it does not recognize, or known bugs in
compiler output.  By default, GDB does not notify you of such
problems, since they are relatively common and primarily of interest
to people debugging compilers.  If you are interested in seeing
information about ill-constructed symbol tables, you can either ask
GDB to print only one message about each such type of problem, no
matter how many times the problem occurs; or you can ask GDB to print
more messages, to see how many times the problems occur, with the `set
complaints' command (*note Optional Warnings and Messages:
Messages/Warnings.).

   The messages currently printed, and their meanings, are:

`inner block not inside outer block in SYMBOL'
     The symbol information shows where symbol scopes begin and end
     (such as at the start of a function or a block of statements). 
     This error indicates that an inner scope block is not fully
     contained in its outer scope blocks.

     GDB circumvents the problem by treating the inner block as if it
     had the same scope as the outer block.  In the error message,
     SYMBOL may be shown as "`(don't know)'" if the outer block is not
     a function.

`block at ADDRESS out of order'
     The symbol information for symbol scope blocks should occur in
     order of increasing addresses.  This error indicates that it does
     not do so.

     GDB does not circumvent this problem, and will have trouble
     locating symbols in the source file whose symbols being read. 
     (You can often determine what source file is affected by
     specifying `set verbose on'.  *Note Optional Warnings and
     Messages: Messages/Warnings.)

`bad block start address patched'
     The symbol information for a symbol scope block has a start
     address smaller than the address of the preceding source line. 
     This is known to occur in the SunOS 4.1.1 (and earlier) C
     compiler.

     GDB circumvents the problem by treating the symbol scope block as
     starting on the previous source line.

`bad string table offset in symbol N'
     Symbol number N contains a pointer into the string table which is
     larger than the size of the string table.

     GDB circumvents the problem by considering the symbol to have the
     name `foo', which may cause other problems if many symbols end up
     with this name.

`unknown symbol type `0xNN''
     The symbol information contains new data types that GDB does not
     yet know how to read.  `0xNN' is the symbol type of the
     misunderstood information, in hexadecimal.

     GDB circumvents the error by ignoring this symbol information. 
     This will usually allow your program to be debugged, though
     certain symbols will not be accessible.  If you encounter such a
     problem and feel like debugging it, you can debug `gdb' with
     itself, breakpoint on `complain', then go up to the function
     `read_dbx_symtab' and examine `*bufp' to see the symbol.

`stub type has NULL name'
     GDB could not find the full definition for a struct or class.

`const/volatile indicator missing (ok if using g++ v1.x), got...'
     The symbol information for a C++ member function is missing some
     information that recent versions of the compiler should have
     output for it.

`info mismatch between compiler and debugger'
     GDB could not parse a type specification output by the compiler.


File: gdb.info,  Node: Targets,  Next: Controlling GDB,  Prev: GDB Files,  Up: Top

Specifying a Debugging Target
*****************************

   A "target" is the execution environment occupied by your program. 
Often, GDB runs in the same host environment as your program; in that
case, the debugging target is specified as a side effect when you use
the `file' or `core' commands.  When you need more flexibility--for
example, running GDB on a physically separate host, or controlling a
standalone system over a serial port or a realtime system over a
TCP/IP connection--you can use the `target' command to specify one of
the target types configured for GDB (*note Commands for Managing
Targets: Target Commands.).

* Menu:

* Active Targets::              Active Targets
* Target Commands::             Commands for Managing Targets
* Remote::                      Remote Debugging


File: gdb.info,  Node: Active Targets,  Next: Target Commands,  Prev: Targets,  Up: Targets

Active Targets
==============

   There are three classes of targets: processes, core files, and
executable files.  GDB can work concurrently on up to three active
targets, one in each class.  This allows you to (for example) start a
process and inspect its activity without abandoning your work on a core
file.

   If, for example, you execute `gdb a.out', then the executable file
`a.out' is the only active target.  If you designate a core file as
well--presumably from a prior run that crashed and coredumped--then
GDB has two active targets and will use them in tandem, looking first
in the corefile target, then in the executable file, to satisfy
requests for memory addresses.  (Typically, these two classes of target
are complementary, since core files contain only a program's
read-write memory--variables and so on--plus machine status, while
executable files contain only the program text and initialized data.)

   When you type `run', your executable file becomes an active process
target as well.  When a process target is active, all GDB commands
requesting memory addresses refer to that target; addresses in an
active core file or executable file target are obscured while the
process target is active.

   Use the `core-file' and `exec-file' commands to select a new core
file or executable target (*note Commands to Specify Files: Files.). 
To specify as a target a process that is already running, use the
`attach' command (*note Debugging an Already-Running Process:
Attach..).


File: gdb.info,  Node: Target Commands,  Next: Remote,  Prev: Active Targets,  Up: Targets

Commands for Managing Targets
=============================

`target TYPE PARAMETERS'
     Connects the GDB host environment to a target machine or process.
      A target is typically a protocol for talking to debugging
     facilities.  You use the argument TYPE to specify the type or
     protocol of the target machine.

     Further PARAMETERS are interpreted by the target protocol, but
     typically include things like device names or host names to
     connect with, process numbers, and baud rates.

     The `target' command will not repeat if you press RET again after
     executing the command.

`help target'
     Displays the names of all targets available.  To display targets
     currently selected, use either `info target' or `info files'
     (*note Commands to Specify Files: Files.).

`help target NAME'
     Describe a particular target, including any parameters necessary
     to select it.

   Here are some common targets (available, or not, depending on the
GDB configuration):

`target exec PROG'
     An executable file.  `target exec PROG' is the same as `exec-file
     PROG'.

`target core FILENAME'
     A core dump file.  `target core FILENAME' is the same as
     `core-file FILENAME'.

`target remote DEV'
     Remote serial target in GDB-specific protocol.  The argument DEV
     specifies what serial device to use for the connection (e.g. 
     `/dev/ttya'). *Note Remote Debugging: Remote.

`target amd-eb DEV SPEED PROG'
     Remote PC-resident AMD EB29K board, attached over serial lines. 
     DEV is the serial device, as for `target remote'; SPEED allows
     you to specify the linespeed; and PROG is the name of the program
     to be debugged, as it appears to DOS on the PC.  *Note GDB with a
     Remote EB29K: EB29K Remote.

`target nindy DEVICENAME'
     An Intel 960 board controlled by a Nindy Monitor.  DEVICENAME is
     the name of the serial device to use for the connection, e.g. 
     `/dev/ttya'.  *Note GDB with a Remote i960 (Nindy): i960-Nindy
     Remote.

`target vxworks MACHINENAME'
     A VxWorks system, attached via TCP/IP.  The argument MACHINENAME
     is the target system's machine name or IP address.  *Note GDB and
     VxWorks: VxWorks Remote.

   Different targets are available on different configurations of GDB;
your configuration may have more or fewer targets.


File: gdb.info,  Node: Remote,  Prev: Target Commands,  Up: Targets

Remote Debugging
================

   If you are trying to debug a program running on a machine that
cannot run GDB in the usual way, it is often useful to use remote
debugging.  For example, you might use remote debugging on an
operating system kernel, or on a small system which does not have a
general purpose operating system powerful enough to run a
full-featured debugger.

   Some configurations of GDB have special serial or TCP/IP interfaces
to make this work with particular debugging targets.  In addition, GDB
comes with a generic serial protocol (specific to GDB, but not
specific to any particular target system) which you can use if you
write the remote stubs--the code that will run on the remote system to
communicate with GDB.

   To use the GDB remote serial protocol, the program to be debugged on
the remote machine needs to contain a debugging stub which talks to
GDB over the serial line.  Several working remote stubs are
distributed with GDB; see the `README' file in the GDB distribution
for more information.

   For details of this communication protocol, see the comments in the
GDB source file `remote.c'.

   To start remote debugging, first run GDB and specify as an
executable file the program that is running in the remote machine. 
This tells GDB how to find your program's symbols and the contents of
its pure text.  Then establish communication using the `target remote'
command with a device name as an argument.  For example:

     target remote /dev/ttyb

if the serial line is connected to the device named `/dev/ttyb'.  This
will stop the remote machine if it is not already stopped.

   Now you can use all the usual commands to examine and change data
and to step and continue the remote program.

   To resume the remote program and stop debugging it, use the `detach'
command.

   Other remote targets may be available in your configuration of GDB;
use `help targets' to list them.

* Menu:

* i960-Nindy Remote::		GDB with a Remote i960 (Nindy)
* EB29K Remote::		GDB with a Remote EB29K
* VxWorks Remote::		GDB and VxWorks


File: gdb.info,  Node: i960-Nindy Remote,  Next: EB29K Remote,  Prev: Remote,  Up: Remote

GDB with a Remote i960 (Nindy)
------------------------------

   "Nindy" is a ROM Monitor program for Intel 960 target systems.  When
GDB is configured to control a remote Intel 960 using Nindy, you can
tell GDB how to connect to the 960 in several ways:

   * Through command line options specifying serial port, version of
     the Nindy protocol, and communications speed;

   * By responding to a prompt on startup;

   * By using the `target' command at any point during your GDB
     session.  *Note Commands for Managing Targets: Target Commands.

* Menu:

* Nindy Startup::               Startup with Nindy
* Nindy Options::               Options for Nindy
* Nindy reset::                 Nindy Reset Command


File: gdb.info,  Node: Nindy Startup,  Next: Nindy Options,  Prev: i960-Nindy Remote,  Up: i960-Nindy Remote

Startup with Nindy
..................

   If you simply start `GDB' without using any command-line options,
you are prompted for what serial port to use, *before* you reach the
ordinary GDB prompt:

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:

Respond to the prompt with whatever suffix (after `/dev/tty')
identifies the serial port you want to use.  You can, if you choose,
simply start up with no Nindy connection by responding to the prompt
with an empty line.  If you do this, and later wish to attach to Nindy,
use `target' (*note Commands for Managing Targets: Target Commands.).


File: gdb.info,  Node: Nindy Options,  Next: Nindy reset,  Prev: Nindy Startup,  Up: i960-Nindy Remote

Options for Nindy
.................

   These are the startup options for beginning your GDB session with a
Nindy-960 board attached:

`-r PORT'
     Specify the serial port name of a serial interface to be used to
     connect to the target system.  This option is only available when
     GDB is configured for the Intel 960 target architecture.  You may
     specify PORT as any of: a full pathname (e.g. `-r /dev/ttya'), a
     device name in `/dev' (e.g. `-r ttya'), or simply the unique
     suffix for a specific `tty' (e.g. `-r a').

`-O'
     (An uppercase letter "O", not a zero.)  Specify that GDB should
     use the "old" Nindy monitor protocol to connect to the target
     system.  This option is only available when GDB is configured for
     the Intel 960 target architecture.

          *Warning:* if you specify `-O', but are actually trying to
          connect to a target system that expects the newer protocol,
          the connection will fail, appearing to be a speed mismatch. 
          GDB will repeatedly attempt to reconnect at several
          different line speeds.  You can abort this process with an
          interrupt.

`-brk'
     Specify that GDB should first send a `BREAK' signal to the target
     system, in an attempt to reset it, before connecting to a Nindy
     target.

          *Warning:* Many target systems do not have the hardware that
          this requires; it only works with a few boards.

   The standard `-b' option controls the line speed used on the serial
port.


File: gdb.info,  Node: Nindy reset,  Prev: Nindy Options,  Up: i960-Nindy Remote

Nindy Reset Command
...................

`reset'
     For a Nindy target, this command sends a "break" to the remote
     target system; this is only useful if the target has been
     equipped with a circuit to perform a hard reset (or some other
     interesting action) when a break is detected.


File: gdb.info,  Node: EB29K Remote,  Next: VxWorks Remote,  Prev: i960-Nindy Remote,  Up: Remote

GDB with a Remote EB29K
-----------------------

   To use GDB from a Unix system to run programs on AMD's EB29K board
in a PC, you must first connect a serial cable between the PC and a
serial port on the Unix system.  In the following, we assume you've
hooked the cable between the PC's `COM1' port and `/dev/ttya' on the
Unix system.

* Menu:

* Comms (EB29K)::               Communications Setup
* gdb-EB29K::                   EB29K cross-debugging
* Remote Log::                  Remote Log


File: gdb.info,  Node: Comms (EB29K),  Next: gdb-EB29K,  Prev: EB29K Remote,  Up: EB29K Remote

Communications Setup
....................

   The next step is to set up the PC's port, by doing something like
the following in DOS on the PC:

     C:\> MODE com1:9600,n,8,1,none

This example--run on an MS DOS 4.0 system--sets the PC port to 9600
bps, no parity, eight data bits, one stop bit, and no "retry" action;
you must match the communications parameters when establishing the Unix
end of the connection as well.

   To give control of the PC to the Unix side of the serial line, type
the following at the DOS console:

     C:\> CTTY com1

(Later, if you wish to return control to the DOS console, you can use
the command `CTTY con'--but you must send it over the device that had
control, in our example over the `COM1' serial line).

   From the Unix host, use a communications program such as `tip' or
`cu' to communicate with the PC; for example,

     cu -s 9600 -l /dev/ttya

The `cu' options shown specify, respectively, the linespeed and the
serial port to use.  If you use `tip' instead, your command line may
look something like the following:

     tip -9600 /dev/ttya

Your system may define a different name where our example uses
`/dev/ttya' as the argument to `tip'.  The communications parameters,
including which port to use, are associated with the `tip' argument in
the "remote" descriptions file--normally the system table
`/etc/remote'.

   Using the `tip' or `cu' connection, change the DOS working
directory to the directory containing a copy of your 29K program, then
start the PC program `EBMON' (an EB29K control program supplied with
your board by AMD).  You should see an initial display from `EBMON'
similar to the one that follows, ending with the `EBMON' prompt `#'--

     C:\> G:
     
     G:\> CD \usr\joe\work29k
     
     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.
     
     Enter '?' or 'H' for help
     
     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000
     
     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff
     
     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800
     
     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes
     
     # ~.

   Then exit the `cu' or `tip' program (done in the example by typing
`~.' at the `EBMON' prompt).  `EBMON' will keep running, ready for GDB
to take over.

   For this example, we've assumed what is probably the most convenient
way to make sure the same 29K program is on both the PC and the Unix
system: a PC/NFS connection that establishes "drive `G:'" on the PC as
a file system on the Unix host.  If you do not have PC/NFS or
something similar connecting the two systems, you must arrange some
other way--perhaps floppy-disk transfer--of getting the 29K program
from the Unix system to the PC; GDB will *not* download it over the
serial line.


File: gdb.info,  Node: gdb-EB29K,  Next: Remote Log,  Prev: Comms (EB29K),  Up: EB29K Remote

EB29K cross-debugging
.....................

   Finally, `cd' to the directory containing an image of your 29K
program on the Unix system, and start GDB--specifying as argument the
name of your 29K program:

     cd /usr/joe/work29k
     gdb myfoo

   Now you can use the `target' command:

     target amd-eb /dev/ttya 9600 MYFOO

In this example, we've assumed your program is in a file called
`myfoo'.  Note that the filename given as the last argument to `target
amd-eb' should be the name of the program as it appears to DOS.  In
our example this is simply `MYFOO', but in general it can include a
DOS path, and depending on your transfer mechanism may not resemble
the name on the Unix side.

   At this point, you can set any breakpoints you wish; when you are
ready to see your program run on the 29K board, use the GDB command
`run'.

   To stop debugging the remote program, use the GDB `detach' command.

   To return control of the PC to its console, use `tip' or `cu' once
again, after your GDB session has concluded, to attach to `EBMON'. 
You can then type the command `q' to shut down `EBMON', returning
control to the DOS command-line interpreter.  Type `CTTY con' to
return command input to the main DOS console, and type `~.' to leave
`tip' or `cu'.


File: gdb.info,  Node: Remote Log,  Prev: gdb-EB29K,  Up: EB29K Remote

Remote Log
..........

   The `target amd-eb' command creates a file `eb.log' in the current
working directory, to help debug problems with the connection. 
`eb.log' records all the output from `EBMON', including echoes of the
commands sent to it.  Running `tail -f' on this file in another window
often helps to understand trouble with `EBMON', or unexpected events
on the PC side of the connection.


File: gdb.info,  Node: VxWorks Remote,  Prev: EB29K Remote,  Up: Remote

GDB and VxWorks
---------------

   GDB enables developers to spawn and debug tasks running on networked
VxWorks targets from a Unix host.  Already-running tasks spawned from
the VxWorks shell can also be debugged.  GDB uses code that runs on
both the UNIX host and on the VxWorks target.  The program `gdb' is
installed and executed on the UNIX host.

   The remote debugging interface (RDB) routines are installed and
executed on the VxWorks target.  These routines are included in the
VxWorks library `rdb.a' and are incorporated into the system image
when source-level debugging is enabled in the VxWorks configuration.

   If you wish, you can define `INCLUDE_RDB' in the VxWorks
configuration file `configAll.h' to include the RDB interface routines
and spawn the source debugging task `tRdbTask' when VxWorks is booted.
 For more information on configuring and remaking VxWorks, see the
manufacturer's manual.

   Once you have included the RDB interface in your VxWorks system
image and set your Unix execution search path to find GDB, you are
ready to run GDB.  From your UNIX host, type:

     % gdb

   GDB will come up showing the prompt:

     (gdb)

* Menu:

* VxWorks connection::          Connecting to VxWorks
* VxWorks download::            VxWorks Download
* VxWorks attach::              Running Tasks


File: gdb.info,  Node: VxWorks connection,  Next: VxWorks download,  Prev: VxWorks Remote,  Up: VxWorks Remote

Connecting to VxWorks
.....................

   The GDB command `target' lets you connect to a VxWorks target on the
network.  To connect to a target whose host name is "`tt'", type:

     (gdb) target vxworks tt

   GDB will display a message similar to the following:

     Attaching remote machine across net... Success!

   GDB will then attempt to read the symbol tables of any object
modules loaded into the VxWorks target since it was last booted.  GDB
locates these files by searching the directories listed in the command
search path (*note Your Program's Environment: Environment.); if it
fails to find an object file, it will display a message such as:

     prog.o: No such file or directory.

   This will cause the `target' command to abort.  When this happens,
you should add the appropriate directory to the search path, with the
GDB command `path', and execute the `target' command again.


File: gdb.info,  Node: VxWorks download,  Next: VxWorks attach,  Prev: VxWorks connection,  Up: VxWorks Remote

VxWorks Download
................

   If you have connected to the VxWorks target and you want to debug an
object that has not yet been loaded, you can use the GDB `load'
command to download a file from UNIX to VxWorks incrementally.  The
object file given as an argument to the `load' command is actually
opened twice: first by the VxWorks target in order to download the
code, then by GDB in order to read the symbol table.  This can lead to
problems if the current working directories on the two systems differ. 
It is simplest to set the working directory on both systems to the
directory in which the object file resides, and then to reference the
file by its name, without any path.  Thus, to load a program `prog.o',
residing in `wherever/vw/demo/rdb', on VxWorks type:

     -> cd "wherever/vw/demo/rdb"

   On GDB type:

     (gdb) cd wherever/vw/demo/rdb
     (gdb) load prog.o

   GDB will display a response similar to the following:

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

   You can also use the `load' command to reload an object module
after editing and recompiling the corresponding source file.  Note that
this will cause GDB to delete all currently-defined breakpoints,
auto-displays, and convenience variables, and to clear the value
history.  (This is necessary in order to preserve the integrity of
debugger data structures that reference the target system's symbol
table.)


File: gdb.info,  Node: VxWorks attach,  Prev: VxWorks download,  Up: VxWorks Remote

Running Tasks
.............

   You can also attach to an existing task using the `attach' command
as follows:

     (gdb) attach TASK

where TASK is the VxWorks hexadecimal task ID.  The task can be running
or suspended when you attach to it.  If running, it will be suspended
at the time of attachment.


File: gdb.info,  Node: Controlling GDB,  Next: Sequences,  Prev: Targets,  Up: Top

Controlling GDB
***************

   You can alter many aspects of GDB's interaction with you by using
the `set' command.  For commands controlling how GDB displays data,
*note Print Settings: Print Settings.; other settings are described
here.

* Menu:

* Prompt::                      Prompt
* Editing::                     Command Editing
* History::                     Command History
* Screen Size::                 Screen Size
* Numbers::                     Numbers
* Messages/Warnings::           Optional Warnings and Messages


File: gdb.info,  Node: Prompt,  Next: Editing,  Prev: Controlling GDB,  Up: Controlling GDB

Prompt
======

   GDB indicates its readiness to read a command by printing a string
called the "prompt".  This string is normally `(gdb)'.  You can change
the prompt string with the `set prompt' command.  For instance, when
debugging GDB with GDB, it is useful to change the prompt in one of
the GDBs so that you can always tell which one you are talking to.

`set prompt NEWPROMPT'
     Directs GDB to use NEWPROMPT as its prompt string henceforth.

`show prompt'
     Prints a line of the form: `Gdb's prompt is: YOUR-PROMPT'


File: gdb.info,  Node: Editing,  Next: History,  Prev: Prompt,  Up: Controlling GDB

Command Editing
===============

   GDB reads its input commands via the "readline" interface.  This
GNU library provides consistent behavior for programs which provide a
command line interface to the user.  Advantages are `emacs'-style or
`vi'-style inline editing of commands, `csh'-like history
substitution, and a storage and recall of command history across
debugging sessions.

   You may control the behavior of command line editing in GDB with the
command `set'.

`set editing'
`set editing on'
     Enable command line editing (enabled by default).

`set editing off'
     Disable command line editing.

`show editing'
     Show whether command line editing is enabled.


File: gdb.info,  Node: History,  Next: Screen Size,  Prev: Editing,  Up: Controlling GDB

Command History
===============

`set history filename FNAME'
     Set the name of the GDB command history file to FNAME.  This is
     the file from which GDB will read an initial command history list
     or to which it will write this list when it exits.  This list is
     accessed through history expansion or through the history command
     editing characters listed below.  This file defaults to the value
     of the environment variable `GDBHISTFILE', or to `./.gdb_history'
     if this variable is not set.

`set history save'
`set history save on'
     Record command history in a file, whose name may be specified
     with the `set history filename' command.  By default, this option
     is disabled.

`set history save off'
     Stop recording command history in a file.

`set history size SIZE'
     Set the number of commands which GDB will keep in its history
     list.  This defaults to the value of the environment variable
     `HISTSIZE', or to 256 if this variable is not set.

   History expansion assigns special meaning to the character `!'. 
Since `!' is also the logical not operator in C, history expansion is
off by default. If you decide to enable history expansion with the
`set history expansion on' command, you may sometimes need to follow
`!' (when it is used as logical not, in an expression) with a space or
a tab to prevent it from being expanded.  The readline history
facilities will not attempt substitution on the strings `!=' and `!(',
even when history expansion is enabled.

   The commands to control history expansion are:

`set history expansion on'
`set history expansion'
     Enable history expansion.  History expansion is off by default.

`set history expansion off'
     Disable history expansion.

     The readline code comes with more complete documentation of
     editing and history expansion features.  Users unfamiliar with
     `emacs' or `vi' may wish to read it.

`show history'
`show history filename'
`show history save'
`show history size'
`show history expansion'
     These commands display the state of the GDB history parameters. 
     `show history' by itself displays all four states.

`show commands'
     Display the last ten commands in the command history.

`show commands N'
     Print ten commands centered on command number N.

`show commands +'
     Print ten commands just after the commands last printed.


File: gdb.info,  Node: Screen Size,  Next: Numbers,  Prev: History,  Up: Controlling GDB

Screen Size
===========

   Certain commands to GDB may produce large amounts of information
output to the screen.  To help you read all of it, GDB pauses and asks
you for input at the end of each page of output.  Type RET when you
want to continue the output.  GDB also uses the screen width setting
to determine when to wrap lines of output.  Depending on what is being
printed, it tries to break the line at a readable place, rather than
simply letting it overflow onto the following line.

   Normally GDB knows the size of the screen from the termcap data base
together with the value of the `TERM' environment variable and the
`stty rows' and `stty cols' settings. If this is not correct, you can
override it with the `set height' and `set width' commands:

`set height LPP'
`show height'
`set width CPL'
`show width'
     These `set' commands specify a screen height of LPP lines and a
     screen width of CPL characters.  The associated `show' commands
     display the current settings.

     If you specify a height of zero lines, GDB will not pause during
     output no matter how long the output is.  This is useful if
     output is to a file or to an editor buffer.


File: gdb.info,  Node: Numbers,  Next: Messages/Warnings,  Prev: Screen Size,  Up: Controlling GDB

Numbers
=======

   You can always enter numbers in octal, decimal, or hexadecimal in
GDB by the usual conventions: octal numbers begin with `0', decimal
numbers end with `.', and hexadecimal numbers begin with `0x'. 
Numbers that begin with none of these are, by default, entered in base
10; likewise, the default display for numbers--when no particular
format is specified--is base 10.  You can change the default base for
both input and output with the `set radix' command.

`set radix BASE'
     Set the default base for numeric input and display.  Supported
     choices for BASE are decimal 2, 8, 10, 16.  BASE must itself be
     specified either unambiguously or using the current default
     radix; for example, any of

          set radix 1010
          set radix 012
          set radix 10.
          set radix 0xa

     will set the base to decimal.  On the other hand, `set radix 10'
     will leave the radix unchanged no matter what it was.

`show radix'
     Display the current default base for numeric input and display.


File: gdb.info,  Node: Messages/Warnings,  Prev: Numbers,  Up: Controlling GDB

Optional Warnings and Messages
==============================

   By default, GDB is silent about its inner workings.  If you are
running on a slow machine, you may want to use the `set verbose'
command.  It will make GDB tell you when it does a lengthy internal
operation, so you will not think it has crashed.

   Currently, the messages controlled by `set verbose' are those which
announce that the symbol table for a source file is being read (*note
Commands to Specify Files: Files., in the description of the command
`symbol-file').

`set verbose on'
     Enables GDB's output of certain informational messages.

`set verbose off'
     Disables GDB's output of certain informational messages.

`show verbose'
     Displays whether `set verbose' is on or off.

   By default, if GDB encounters bugs in the symbol table of an object
file, it is silent; but if you are debugging a compiler, you may find
this information useful (*note Errors Reading Symbol Files: Symbol
Errors.).

`set complaints LIMIT'
     Permits GDB to output LIMIT complaints about each type of unusual
     symbols before becoming silent about the problem.  Set LIMIT to
     zero to suppress all complaints; set it to a large number to
     prevent complaints from being suppressed.

`show complaints'
     Displays how many symbol complaints GDB is permitted to produce.

   By default, GDB is cautious, and asks what sometimes seem to be a
lot of stupid questions to confirm certain commands.  For example, if
you try to run a program which is already running:

     (gdb) run
     The program being debugged has been started already.
     Start it from the beginning? (y or n)

   If you are willing to unflinchingly face the consequences of your
own commands, you can disable this "feature":

`set confirm off'
     Disables confirmation requests.

`set confirm on'
     Enables confirmation requests (the default).

`show confirm'
     Displays state of confirmation requests.

   Some systems allow individual object files that make up your
program to be replaced without stopping and restarting your program. 
For example, in VxWorks you can simply recompile a defective object
file and keep on running.  If you are running on one of these systems,
you can allow GDB to reload the symbols for automatically relinked
modules:

`set symbol-reloading on'
     Replace symbol definitions for the corresponding source file when
     an object file with a particular name is seen again.

`set symbol-reloading off'
     Do not replace symbol definitions when re-encountering object
     files of the same name.  This is the default state; if you are
     not running on a system that permits automatically relinking
     modules, you should leave `symbol-reloading' off, since otherwise
     GDB may discard symbols when linking large programs, that may
     contain several modules (from different directories or libraries)
     with the same name.

`show symbol-reloading'
     Show the current `on' or `off' setting.


File: gdb.info,  Node: Sequences,  Next: Emacs,  Prev: Controlling GDB,  Up: Top

Canned Sequences of Commands
****************************

   Aside from breakpoint commands (*note Breakpoint Command Lists:
Break Commands.), GDB provides two ways to store sequences of commands
for execution as a unit: user-defined commands and command files.

* Menu:

* Define::                      User-Defined Commands
* Command Files::               Command Files
* Output::                      Commands for Controlled Output


File: gdb.info,  Node: Define,  Next: Command Files,  Prev: Sequences,  Up: Sequences

User-Defined Commands
=====================

   A "user-defined command" is a sequence of GDB commands to which you
assign a new name as a command.  This is done with the `define'
command.

`define COMMANDNAME'
     Define a command named COMMANDNAME.  If there is already a command
     by that name, you are asked to confirm that you want to redefine
     it.

     The definition of the command is made up of other GDB command
     lines, which are given following the `define' command.  The end
     of these commands is marked by a line containing `end'.

`document COMMANDNAME'
     Give documentation to the user-defined command COMMANDNAME.  The
     command COMMANDNAME must already be defined.  This command reads
     lines of documentation just as `define' reads the lines of the
     command definition, ending with `end'.  After the `document'
     command is finished, `help' on command COMMANDNAME will print the
     documentation you have specified.

     You may use the `document' command again to change the
     documentation of a command.  Redefining the command with `define'
     does not change the documentation.

`help user-defined'
     List all user-defined commands, with the first line of the
     documentation (if any) for each.

`info user'
`info user COMMANDNAME'
     Display the GDB commands used to define COMMANDNAME (but not its
     documentation).  If no COMMANDNAME is given, display the
     definitions for all user-defined commands.

   User-defined commands do not take arguments.  When they are
executed, the commands of the definition are not printed.  An error in
any command stops execution of the user-defined command.

   Commands that would ask for confirmation if used interactively
proceed without asking when used inside a user-defined command.  Many
GDB commands that normally print messages to say what they are doing
omit the messages when used in a user-defined command.


File: gdb.info,  Node: Command Files,  Next: Output,  Prev: Define,  Up: Sequences

Command Files
=============

   A command file for GDB is a file of lines that are GDB commands. 
Comments (lines starting with `#') may also be included.  An empty
line in a command file does nothing; it does not mean to repeat the
last command, as it would from the terminal.

   When you start GDB, it automatically executes commands from its
"init files".  These are files named `.gdbinit'.  GDB reads the init
file (if any) in your home directory and then the init file (if any)
in the current working directory.  (The init files are not executed if
you use the `-nx' option; *note Choosing Modes: Mode Options..)  You
can also request the execution of a command file with the `source'
command:

`source FILENAME'
     Execute the command file FILENAME.

   The lines in a command file are executed sequentially.  They are not
printed as they are executed.  An error in any command terminates
execution of the command file.

   Commands that would ask for confirmation if used interactively
proceed without asking when used in a command file.  Many GDB commands
that normally print messages to say what they are doing omit the
messages when called from command files.


File: gdb.info,  Node: Output,  Prev: Command Files,  Up: Sequences

Commands for Controlled Output
==============================

   During the execution of a command file or a user-defined command,
normal GDB output is suppressed; the only output that appears is what
is explicitly printed by the commands in the definition.  This section
describes three commands useful for generating exactly the output you
want.

`echo TEXT'
     Print TEXT.  Nonprinting characters can be included in TEXT using
     C escape sequences, such as `\n' to print a newline.  *No newline
     will be printed unless you specify one.* In addition to the
     standard C escape sequences, a backslash followed by a space
     stands for a space.  This is useful for outputting a string with
     spaces at the beginning or the end, since leading and trailing
     spaces are otherwise trimmed from all arguments.  To print ` and
     foo = ', use the command `echo \ and foo = \ '.

     A backslash at the end of TEXT can be used, as in C, to continue
     the command onto subsequent lines.  For example,

          echo This is some text\n\
          which is continued\n\
          onto several lines.\n

     produces the same output as

          echo This is some text\n
          echo which is continued\n
          echo onto several lines.\n

`output EXPRESSION'
     Print the value of EXPRESSION and nothing but that value: no
     newlines, no `$NN = '.  The value is not entered in the value
     history either.  *Note Expressions: Expressions, for more
     information on expressions.

`output/FMT EXPRESSION'
     Print the value of EXPRESSION in format FMT.  You can use the
     same formats as for `print'; *note Output formats::., for more
     information.

`printf STRING, EXPRESSIONS...'
     Print the values of the EXPRESSIONS under the control of STRING. 
     The EXPRESSIONS are separated by commas and may be either numbers
     or pointers.  Their values are printed as specified by STRING,
     exactly as if your program were to execute

          printf (STRING, EXPRESSIONS...);

     For example, you can print two values in hex like this:

          printf "foo, bar-foo = 0x%x, 0x%x\n", foo, bar-foo

     The only backslash-escape sequences that you can use in the format
     string are the simple ones that consist of backslash followed by a
     letter.

